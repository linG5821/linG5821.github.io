## 源码解析

## 架构设计
### 逻辑架构
Netty采用典型的三层网络架构进行设计和开发, 逻辑架构如图:
![Netty逻辑架构](https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo/202202071905948.png)

* Reactor通信调度层

主要负责监听网络的读写和连接操作, 负责将网络层的数据读取到内存缓冲区中, 然后触发各种网络时事件, 例如连接创建、连接激活、读事件、写事件等, 将这些事件触发到 `pipeline` 中, 由 `pipeline` 管理的职责链来进行后续的处理

* 职责链 ChannelPipeline

主要负责事件在职责链中的有序传播, 同时负责动态的编排职责链。职责链可以选择监听和处理自己关心的事件, 它可以拦截处理和向后/向前传播事件。不同应用的 Handler节点功能也不同, 通常情况下, 往往会开发编解码 Handler 用于消息的编解码, 可以将外部的协议消息转换成内部的POJO对象, 这样上层业务只需要关心处理业务逻辑即可, 不需要感知底层的协议差异和线程模型差异, 实现了架构层面的分层隔离

* 业务逻辑编排层 Service ChannelHandler

业务逻辑编排层通常有两类: 一类是纯粹的业务逻辑编排, 还有一类是其他应用层协议插件, 用于特定协议相关的会话和链路管理。例如 CMPP 协议, 用于管理和中国移动短信系统的对接

对于业务开发者, 只需要关心职责链拦截的业务 Handler 的编排和服务层的业务逻辑开发即可。各种应用协议以插件的形式提供, 只有协议开发人员需要关注协议插件, 业务开发人员只需关心业务逻辑即可

### 关键架构质量属性
* 高性能
    - 采用异步非阻塞的 I/O 类库, 基于Reactor 模式实现, 解决了传统同步阻塞 I/O 模式下一个服务端无法平滑地处理线性增长的客户端的问题
    - TCP 接收和发送缓冲区使用直接内存代替堆内存, 避免了内存复制, 提升了 I/O 读取和写入的性能
    - TODO
* 可靠性
* 可定制性
* 可扩展性

## 经典问题答疑及案例

## 实践案例