## 动态代理
* 基于接口 ( JDK动态代理 )
* 基于类 ( cglib )
* 字节码实现 ( javassist )


## 并发编程

### 并发编程的建议
#### 锁的使用
1. 为了保证性能,应尽可能保证锁的**细粒度**
2. `wait` 方法用来使线程等待某个条件, 它必须在同步快内部被调用,标准使用方式如下

    ```java
    synchronized(this) {
        while(condition) {
            Object.wait;
        }
        .....
    }
    ```
3. 始终使用 `wait` 循环来调用 wait 方法, 永远不要在循环之外调用 `wait` 方法,这样做的原因是**尽管并不满足被唤醒条件,但是由于其他线程调用 `notifyAll()` 方法会导致被阻塞线程意外唤醒, 此时执行条件并不满足, 它将破坏被锁保护的约定关系, 导致约束失效**
4. 唤醒线程, 应该使用 `notify` 还是 `notifyAll`, **当你不知道究竟调用哪个方法的时,保守的做法是调用 `notifyAll` 唤醒所有等待线程**。从优化的角度看, 如果处于等待的所有线程都在等待同一条件,而每次只有一个线程可以从这个条件中被唤醒, 那么应该选择调用 `notify`
5. 当多个线程共享同一个变量的时候,每个读或者写数据的操作方法都必须加锁同步, 如果没有正确的同步就无法保证一个线程所做的修改被其他线程共享, 但通过增加 `volatile` 关键字, 可以再一定程度上避免读操作加锁

#### volatile的使用
1. 当一个变量被 `volatile` 修饰后,具备如下两种特性:
  * 线程可见性: 当一个线程修改了呗 `volatile` 修饰的变量后, 无论是否加锁其他线程可以立即看到最新的修改
  * 禁止指令重排序优化, 普通的变量仅仅保证在该方法的执行过程中所有依赖赋值结果的地方获取正确的结果,而不能保证变量赋值
2. `volatile` 仅仅解决了可见性问题,但是它并不能保证互斥性,多个线程并发修改某个变量时,仍旧会产生多线程问题。因此不能靠 `volatile` 来完全代替传统的锁
3. `volatile` 最适合使用的是一个线程写, 其他线程读的场合, 如果有多个线程并发写操作, 仍然需要使用锁或者线程安全的容器或者原子变量来代替

#### CAS指令和原子类
1. 互斥同步最主要的问题是进行线程阻塞和唤醒所带来的性能的额外损耗,这种同步被称为**阻塞同步**, 属于一种悲观的并发策略,称之为悲观锁。与此相对的是非阻塞同步,被称为**乐观锁**, Java中应用最广泛的非阻塞同步就是CAS, JDK 1.5 以后提供了很多CAS包装类来简化使用, 如 `AtomicInteger`
2. 常见的我们可以使用**CAS自旋操作**进行更新操作, 判断更新操作是否成功. 成功则退出循环, 如果失败,进行相应的补偿操作,例如更新旧值并重新计算继续循环直到成功。使用自带的 Atomic 原子类, 可以避免同步锁带来的并发访问性能降低的问题

#### 线程安全类

1. JDK1.5 新的并发工具包分为如下4类:
   * 线程池Executor Framework 以及定时任务相关的类库
   * 并发集合, 包括List、Queue、Map 和 Set 等
   * 新的同步器, 例如读写锁 ReadWriteLock, 重入锁 ReentrantLock 等
   * 新的原子包装类, 例如AtomicInteger 等

2. 建议使用线程池, Task, 原子类和线程安全容器来代替传统的同步锁、wait 和 notify, 从而提升并发访问的性能、降低多线程编程的难度

### 线程状态

1. 线程状态图

![](https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo/3756800208-5c1b354a84566_fix732.jpg)