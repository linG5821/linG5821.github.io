import{_ as e,c as t,b as r,o as s}from"./app-CYKM0tKh.js";const i={};function n(o,a){return s(),t("div",null,a[0]||(a[0]=[r('<h2 id="响应式编程-reactive" tabindex="-1"><a class="header-anchor" href="#响应式编程-reactive"><span>响应式编程（Reactive）</span></a></h2><h2 id="响应式系统的特质" tabindex="-1"><a class="header-anchor" href="#响应式系统的特质"><span>响应式系统的特质</span></a></h2><ul><li><strong>即时响应性</strong>: 快速/一致的响应性。系统不因并发的压力增大而导致响应时间明显变慢，假设500并发操作系统的响应时间为1s，那么增加至5万并发操作时，响应时间也应该为1s左右</li><li><strong>回弹性(韧性)</strong>: 复制/遏制/隔绝/委托。当某个模块出现问题时，需要将这个问题控制在一定的范围内，这时就需要使用隔绝的技术，避免连锁性问题发生。或者将出现故障部分的任务委托给其他模块。韧性主要强调的是系统对于错误的容忍。</li><li><strong>弹性</strong>: 无竞争点或中心瓶颈/分片/扩展。没有状态则水平扩展，如果存在状态，就使用分片技术，将数据分片到不同的机器</li><li><strong>消息驱动</strong>: 异步/松耦合/隔绝/地址透明/错误作为消息/背压/无阻塞。消息驱动是实现上述三项技术支撑。地址透明有很多方法 例如DNS提供一串人类能够读懂的地址，而不是IP，这是一种不依赖于实现，而依赖于声明的设计。再例如k8s每个Service后会有多个pod，依赖一个虚拟服务而不是某一个真实的实例，从而实现调用一个或调用n个对于调用方无感知，这是为分片或扩展做了准备。错误作为消息，在Java中不太常见，Java中通常将错误直接作为异常抛出，而在响应式中错误也是一种消息，和普通消息地位一致，类似JavaScript中的Promise。背压是指当上游向下游推送数据时，下游可能承受能力不足导致问题，因此下游需要向上游声明每次能够接受大约多少量的数据，当接受完毕再次申请，这便转换成了下游向上游申请数据，而不是上游向下游推送数据。无阻塞使用通过NIO(no-blocking IO)提供更高的多线程切换效率</li></ul><h2 id="反应式框架和工具包" tabindex="-1"><a class="header-anchor" href="#反应式框架和工具包"><span>反应式框架和工具包</span></a></h2><ul><li><strong>Rxjava</strong>:</li><li><strong>Reactor</strong>:</li><li><strong>Akaka</strong>:</li><li><strong>Vert.x</strong>:</li></ul><h2 id="reactor-使用" tabindex="-1"><a class="header-anchor" href="#reactor-使用"><span>Reactor 使用</span></a></h2>',6)]))}const c=e(i,[["render",n]]),h=JSON.parse('{"path":"/java/reactive.html","title":"","lang":"en-US","frontmatter":{},"git":{"updatedTime":1767610787000,"contributors":[{"name":"lsj","username":"lsj","email":"lishaojie@aithu.com","commits":1,"url":"https://github.com/lsj"}],"changelog":[{"hash":"c44cbade27df20e77d4204fe0fa76423b764227a","time":1767610787000,"email":"lishaojie@aithu.com","author":"lsj","message":"add javaenv"}]},"filePathRelative":"java/reactive.md"}');export{c as comp,h as data};
