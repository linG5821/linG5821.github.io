(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{296:function(t,a,r){"use strict";r.r(a);var s=r(10),v=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"响应式编程-reactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式编程-reactive"}},[t._v("#")]),t._v(" 响应式编程（Reactive）")]),t._v(" "),a("h2",{attrs:{id:"响应式系统的特质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式系统的特质"}},[t._v("#")]),t._v(" 响应式系统的特质")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("即时响应性")]),t._v(": 快速/一致的响应性。系统不因并发的压力增大而导致响应时间明显变慢，假设500并发操作系统的响应时间为1s，那么增加至5万并发操作时，响应时间也应该为1s左右")]),t._v(" "),a("li",[a("strong",[t._v("回弹性(韧性)")]),t._v(": 复制/遏制/隔绝/委托。当某个模块出现问题时，需要将这个问题控制在一定的范围内，这时就需要使用隔绝的技术，避免连锁性问题发生。或者将出现故障部分的任务委托给其他模块。韧性主要强调的是系统对于错误的容忍。")]),t._v(" "),a("li",[a("strong",[t._v("弹性")]),t._v(": 无竞争点或中心瓶颈/分片/扩展。没有状态则水平扩展，如果存在状态，就使用分片技术，将数据分片到不同的机器")]),t._v(" "),a("li",[a("strong",[t._v("消息驱动")]),t._v(": 异步/松耦合/隔绝/地址透明/错误作为消息/背压/无阻塞。消息驱动是实现上述三项技术支撑。地址透明有很多方法 例如DNS提供一串人类能够读懂的地址，而不是IP，这是一种不依赖于实现，而依赖于声明的设计。再例如k8s每个Service后会有多个pod，依赖一个虚拟服务而不是某一个真实的实例，从而实现调用一个或调用n个对于调用方无感知，这是为分片或扩展做了准备。错误作为消息，在Java中不太常见，Java中通常将错误直接作为异常抛出，而在响应式中错误也是一种消息，和普通消息地位一致，类似JavaScript中的Promise。背压是指当上游向下游推送数据时，下游可能承受能力不足导致问题，因此下游需要向上游声明每次能够接受大约多少量的数据，当接受完毕再次申请，这便转换成了下游向上游申请数据，而不是上游向下游推送数据。无阻塞使用通过NIO(no-blocking IO)提供更高的多线程切换效率")])]),t._v(" "),a("h2",{attrs:{id:"反应式框架和工具包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#反应式框架和工具包"}},[t._v("#")]),t._v(" 反应式框架和工具包")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Rxjava")]),t._v(":")]),t._v(" "),a("li",[a("strong",[t._v("Reactor")]),t._v(":")]),t._v(" "),a("li",[a("strong",[t._v("Akaka")]),t._v(":")]),t._v(" "),a("li",[a("strong",[t._v("Vert.x")]),t._v(":")])]),t._v(" "),a("h2",{attrs:{id:"reactor-使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactor-使用"}},[t._v("#")]),t._v(" Reactor 使用")])])}),[],!1,null,null,null);a.default=v.exports}}]);