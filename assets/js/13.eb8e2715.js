(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{418:function(v,_,t){"use strict";t.r(_);var s=t(32),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"mysql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[v._v("#")]),v._v(" MySQL")]),v._v(" "),t("h2",{attrs:{id:"数据库设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库设计"}},[v._v("#")]),v._v(" 数据库设计")]),v._v(" "),t("ol",[t("li",[v._v("数据库设计中表中字段日期/时间类型的选择\n"),t("ul",[t("li",[v._v("datetime 类型\n"),t("ol",[t("li",[v._v("与时区无关,记录数据的原始时间,不随着时区的变化而变化")]),v._v(" "),t("li",[v._v("5.6 版本之后可以使用当前时间作为默认值,并且由原来的8字节变成5字节")]),v._v(" "),t("li",[v._v("无需任何转换,人类可读")]),v._v(" "),t("li",[v._v("支持更大的时间范围(1000 年 ~ 9999 年)")]),v._v(" "),t("li",[v._v("允许为空值")])])]),v._v(" "),t("li",[v._v("timestamp 类型\n"),t("ol",[t("li",[v._v("随时区变化, 存储时对当前的时区进行转换，检索时再转换回当前的时区")]),v._v(" "),t("li",[v._v("UTC 格式保存")]),v._v(" "),t("li",[v._v("TIMESTAMP值不能早于1970或晚于2038(1901-12-13 到 2038-01-19 03:14:07)")]),v._v(" "),t("li",[v._v("占用4个字节")]),v._v(" "),t("li",[v._v("默认值为当前系统时间,随着记录中其他字段的值变更,该字段也会变更")])])]),v._v(" "),t("li",[v._v("int bigint 存储整数类型\n"),t("ol",[t("li",[v._v("占用4/8 个字节")]),v._v(" "),t("li",[v._v("建立索引后查询速度快")]),v._v(" "),t("li",[v._v("不能时间mysql的时间函数")]),v._v(" "),t("li",[v._v("条件范围搜索可以使用 between")])])])])])]),v._v(" "),t("h2",{attrs:{id:"sql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sql"}},[v._v("#")]),v._v(" SQL")]),v._v(" "),t("h2",{attrs:{id:"mysql原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql原理"}},[v._v("#")]),v._v(" Mysql原理")]),v._v(" "),t("h3",{attrs:{id:"mysql基本架构示意图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql基本架构示意图"}},[v._v("#")]),v._v(" Mysql基本架构示意图")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo0d2070e8f84c4801adbfa03bda1f98d9.webp",alt:"Mysql基本架构示意图"}}),v._v("\nMySQL 可以分为 Server 层和存储引擎层两部分。")]),v._v(" "),t("p",[v._v("Server 层包括"),t("strong",[v._v("连接器")]),v._v("、"),t("strong",[v._v("查询缓存")]),v._v("、"),t("strong",[v._v("分析器")]),v._v("、"),t("strong",[v._v("优化器")]),v._v("、"),t("strong",[v._v("执行器")]),v._v("等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如"),t("strong",[v._v("存储过程")]),v._v("、"),t("strong",[v._v("触发器")]),v._v("、"),t("strong",[v._v("视图")]),v._v("等。不同的存储引擎共用一个 Server 层。")]),v._v(" "),t("p",[v._v("而存储引擎层负责数据的存储和提取。其架构模式是"),t("strong",[v._v("插件式")]),v._v("的，支持 "),t("strong",[v._v("InnoDB")]),v._v("、"),t("strong",[v._v("MyISAM")]),v._v("、"),t("strong",[v._v("Memory")]),v._v(" 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("存储引擎简单对比：1、InnoDB支持事务，而MyISAM不支持事务 2、InnoDB支持行级锁，而MyISAM支持表级锁 3、InnoDB支持MVCC, 而MyISAM不支持 4、InnoDB支持外键，而MyISAM不支持 5、InnoDB不支持全文索引，而MyISAM支持。")])]),v._v(" "),t("h3",{attrs:{id:"连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接器"}},[v._v("#")]),v._v(" 连接器")]),v._v(" "),t("p",[v._v("不要将密码直接写在 "),t("code",[v._v("-p")]),v._v(" 之后，这样会导致密码泄漏，通过 "),t("code",[v._v("history")]),v._v(" 可以查看历史输入的命令。")]),v._v(" "),t("p",[v._v("用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。"),t("strong",[v._v("权限信息连接建立时读到的快照")]),v._v("，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。"),t("strong",[v._v("修改用户权限，不会影响已经存在的连接")]),v._v("，只有再新建的连接才会使用新的权限设置。")]),v._v(" "),t("p",[v._v("连接完成后，如果没有后续的动作，这个连接就处于空闲状态，通过 "),t("code",[v._v("show processlist;")]),v._v(" 命令可以查看当前的连接。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。可以通过 "),t("code",[v._v("show variables like 'wait_timeout';")]),v._v("来查看。")]),v._v(" "),t("p",[v._v("如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。")]),v._v(" "),t("p",[v._v("数据库中，"),t("strong",[v._v("长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接")]),v._v("。"),t("strong",[v._v("短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个")]),v._v("。建立连接的过程通常是比较复杂的，"),t("strong",[v._v("使用中要尽量减少建立连接的动作，也就是尽量使用长连接")]),v._v("。")]),v._v(" "),t("p",[v._v("全部使用长连接后，有些时候会导致 MySQL "),t("strong",[v._v("占用内存涨得特别快")]),v._v("，这是因为 "),t("strong",[v._v("MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("解决长连接占用内存过大的两种方案")]),v._v("：")]),v._v(" "),t("ol",[t("li",[v._v("定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。")]),v._v(" "),t("li",[v._v("如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。")])]),v._v(" "),t("h3",{attrs:{id:"查询缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查询缓存"}},[v._v("#")]),v._v(" 查询缓存")]),v._v(" "),t("p",[v._v("Mysql拿到一个查询请求，会优先查看是否具有缓存，历史执行的语句是通过 key-value 对的形式，被直接缓存在内存中的，如果查询能够直接匹配缓存，value会被直接返回给客户端，不再进行后续操作。显然这样的效率会很高，但是"),t("strong",[v._v("查询缓存往往弊大于利")]),v._v("，所以在"),t("strong",[v._v("mysql8.0中直接移除了查询缓存")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"分析器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析器"}},[v._v("#")]),v._v(" 分析器")]),v._v(" "),t("p",[v._v("mysql需要你知道你要做什么，因此需要解析SQL，分析器会优先做词法分析，识别出语句中的字符串分别是什么，代表什么。然后需要做语法分析，根据语法规则判断输入的SQL是否满足语法要求，语句不对会收到“You have an error in your SQL syntax”的错误提醒。")]),v._v(" "),t("p",[v._v("一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。")]),v._v(" "),t("h3",{attrs:{id:"优化器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化器"}},[v._v("#")]),v._v(" 优化器")]),v._v(" "),t("p",[v._v("mysql知道你要做什么，还需要根据需求选择一个最优方案，决定怎么做，原则是尽可能扫描少的行记录。优化器"),t("strong",[v._v("会决定使用哪个索引，以及多表关联的连接顺序")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"执行器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行器"}},[v._v("#")]),v._v(" 执行器")]),v._v(" "),t("p",[v._v("执行器在执行时，会判断对这个表有没有权限，没有权限会返回没有权限的错误。权限验证在分析器阶段也会做，叫做 “precheck”, 但是无法对运行中涉及的表进行权限验证，比如使用了触发器的情况，因此执行器阶段也需要做一次权限验证。")]),v._v(" "),t("p",[v._v("执行器会根据表的引擎定义，去调用对应的引擎提供的API进行数据操作，所以数据库引擎是插件形式的。")]),v._v(" "),t("p",[v._v("在没有索引的条件下执行器的执行流程是这样的：")]),v._v(" "),t("ol",[t("li",[v._v("调用 InnoDB 引擎接口取这个表的第一行，判断 是否满足条件，如果不是则跳过，如果是则将这行存在结果集中。")]),v._v(" "),t("li",[v._v("调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。")]),v._v(" "),t("li",[v._v("执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。")])]),v._v(" "),t("p",[v._v("有索引的情况，执行器调用的是SQL引擎的API，也就是说无索引是执行器过滤数据，有索引时是引擎接口过滤数据。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此"),t("strong",[v._v("引擎扫描行数跟 rows_examined 并不是完全相同的")]),v._v(" 。rows_examined代表执行器调用存储引擎的次数，一般情况小于引擎扫描行数。")])]),v._v(" "),t("h2",{attrs:{id:"疑难解答"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#疑难解答"}},[v._v("#")]),v._v(" 疑难解答")]),v._v(" "),t("ol",[t("li",[t("code",[v._v("select * from tableA group by cid")]),v._v(" 语句返回的非 group 字段值到底是什么?")])]),v._v(" "),t("p",[v._v("答: group by 时，那些不参与 grouping 的字段具体返回哪条数据在 MySQL5.7 (包括5.7) 之前的版本处于未定义规则状态，官方文档不承诺一定会返回哪条数据， group by 返回的是根据主键顺序，也是没有依据的。")])])}),[],!1,null,null,null);_.default=r.exports}}]);