<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据库设计 | Yolo Cloud</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/favicon.png">
    <meta name="description" content="Yolo Cloud 记录了我技术成长中学到的各种知识,遇到的各种问题">
    
    <link rel="preload" href="/assets/css/0.styles.ef76fb7a.css" as="style"><link rel="preload" href="/assets/js/app.8b02bca0.js" as="script"><link rel="preload" href="/assets/js/2.f0a5ede2.js" as="script"><link rel="preload" href="/assets/js/1.b1f9bc46.js" as="script"><link rel="preload" href="/assets/js/30.a38e59fa.js" as="script"><link rel="prefetch" href="/assets/js/10.e34437a3.js"><link rel="prefetch" href="/assets/js/11.2ac4c563.js"><link rel="prefetch" href="/assets/js/12.8811f863.js"><link rel="prefetch" href="/assets/js/13.e33c9f1a.js"><link rel="prefetch" href="/assets/js/14.d189864d.js"><link rel="prefetch" href="/assets/js/15.b8cbc93b.js"><link rel="prefetch" href="/assets/js/16.f81e8873.js"><link rel="prefetch" href="/assets/js/17.8ce53420.js"><link rel="prefetch" href="/assets/js/18.eb4ada07.js"><link rel="prefetch" href="/assets/js/19.543cb74c.js"><link rel="prefetch" href="/assets/js/20.71d66c7d.js"><link rel="prefetch" href="/assets/js/21.ff4ddfa8.js"><link rel="prefetch" href="/assets/js/22.3524a129.js"><link rel="prefetch" href="/assets/js/23.e0411f18.js"><link rel="prefetch" href="/assets/js/24.11853f02.js"><link rel="prefetch" href="/assets/js/25.40f139e1.js"><link rel="prefetch" href="/assets/js/26.2fbe0a85.js"><link rel="prefetch" href="/assets/js/27.446e1e33.js"><link rel="prefetch" href="/assets/js/28.32892409.js"><link rel="prefetch" href="/assets/js/29.5a2b13bb.js"><link rel="prefetch" href="/assets/js/3.c8520702.js"><link rel="prefetch" href="/assets/js/31.a50a8381.js"><link rel="prefetch" href="/assets/js/32.c6847094.js"><link rel="prefetch" href="/assets/js/33.0c49d146.js"><link rel="prefetch" href="/assets/js/34.f9e23d8d.js"><link rel="prefetch" href="/assets/js/35.74cf6739.js"><link rel="prefetch" href="/assets/js/36.71be65e7.js"><link rel="prefetch" href="/assets/js/37.a8f50a47.js"><link rel="prefetch" href="/assets/js/38.60bda7ec.js"><link rel="prefetch" href="/assets/js/39.e81b415f.js"><link rel="prefetch" href="/assets/js/4.c5e770fe.js"><link rel="prefetch" href="/assets/js/40.159dc556.js"><link rel="prefetch" href="/assets/js/41.796f71f2.js"><link rel="prefetch" href="/assets/js/42.25ea701b.js"><link rel="prefetch" href="/assets/js/43.9dff9f08.js"><link rel="prefetch" href="/assets/js/44.cf6a7133.js"><link rel="prefetch" href="/assets/js/45.229ca46d.js"><link rel="prefetch" href="/assets/js/46.8626bfdd.js"><link rel="prefetch" href="/assets/js/47.3385f5ec.js"><link rel="prefetch" href="/assets/js/48.a30573be.js"><link rel="prefetch" href="/assets/js/49.146fdfee.js"><link rel="prefetch" href="/assets/js/5.417f2406.js"><link rel="prefetch" href="/assets/js/50.bedffd55.js"><link rel="prefetch" href="/assets/js/51.fc75e8af.js"><link rel="prefetch" href="/assets/js/52.eda4be03.js"><link rel="prefetch" href="/assets/js/53.248db3e5.js"><link rel="prefetch" href="/assets/js/54.02136a92.js"><link rel="prefetch" href="/assets/js/55.aa10dd82.js"><link rel="prefetch" href="/assets/js/56.b9e6424d.js"><link rel="prefetch" href="/assets/js/57.b4f774d2.js"><link rel="prefetch" href="/assets/js/6.c5ef4f48.js"><link rel="prefetch" href="/assets/js/7.955a46ff.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5a4296f1.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ef76fb7a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Yolo Cloud</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://github.com/linG5821" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://github.com/linG5821" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/machine/" class="sidebar-heading clickable"><span>机器环境</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/network/" class="sidebar-link">网络编程</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/database/" class="sidebar-heading clickable router-link-active open"><span>数据库</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/database/redis.html" class="sidebar-link">Redis</a></li><li><a href="/database/mysql.html" aria-current="page" class="active sidebar-link">MySQL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/mysql.html#数据库设计" class="sidebar-link">数据库设计</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#sql-实践" class="sidebar-link">SQL 实践</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#mysql原理" class="sidebar-link">MySQL原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/mysql.html#mysql基本架构示意图" class="sidebar-link">Mysql基本架构示意图</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#连接器" class="sidebar-link">连接器</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#查询缓存" class="sidebar-link">查询缓存</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#分析器" class="sidebar-link">分析器</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#优化器" class="sidebar-link">优化器</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#执行器" class="sidebar-link">执行器</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#日志模块" class="sidebar-link">日志模块</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#事务" class="sidebar-link">事务</a></li><li class="sidebar-sub-header"><a href="/database/mysql.html#索引" class="sidebar-link">索引</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/mysql.html#疑难解答" class="sidebar-link">疑难解答</a></li></ul></li><li><a href="/database/mongodb.html" class="sidebar-link">MongoDB</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/middleware/" class="sidebar-heading clickable"><span>中间件</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/container/" class="sidebar-heading clickable"><span>容器技术</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/tool/" class="sidebar-heading clickable"><span>常用工具</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/security/" class="sidebar-heading clickable"><span>安全技术</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/java/" class="sidebar-heading clickable"><span>Java</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/go/" class="sidebar-link">Go</a></li><li><a href="/php/" class="sidebar-link">PHP</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/ai/" class="sidebar-heading clickable"><span>人工智能</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="数据库设计"><a href="#数据库设计" class="header-anchor">#</a> 数据库设计</h2> <ol><li>数据库设计中表中字段日期/时间类型的选择
<ul><li>datetime 类型
<ol><li>与时区无关,记录数据的原始时间,不随着时区的变化而变化</li> <li>5.6 版本之后可以使用当前时间作为默认值,并且由原来的8字节变成5字节</li> <li>无需任何转换,人类可读</li> <li>支持更大的时间范围(1000 年 ~ 9999 年)</li> <li>允许为空值</li></ol></li> <li>timestamp 类型
<ol><li>随时区变化, 存储时对当前的时区进行转换，检索时再转换回当前的时区</li> <li>UTC 格式保存</li> <li>TIMESTAMP值不能早于1970或晚于2038(1901-12-13 到 2038-01-19 03:14:07)</li> <li>占用4个字节</li> <li>默认值为当前系统时间,随着记录中其他字段的值变更,该字段也会变更</li></ol></li> <li>int bigint 存储整数类型
<ol><li>占用4/8 个字节</li> <li>建立索引后查询速度快</li> <li>不能时间mysql的时间函数</li> <li>条件范围搜索可以使用 between</li></ol></li></ul></li></ol> <h2 id="sql-实践"><a href="#sql-实践" class="header-anchor">#</a> SQL 实践</h2> <p>TODO</p> <h2 id="mysql原理"><a href="#mysql原理" class="header-anchor">#</a> MySQL原理</h2> <h3 id="mysql基本架构示意图"><a href="#mysql基本架构示意图" class="header-anchor">#</a> Mysql基本架构示意图</h3> <p><img src="https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo/0d2070e8f84c4801adbfa03bda1f98d9.webp" alt="Mysql基本架构示意图">
MySQL 可以分为 Server 层和存储引擎层两部分。</p> <p>Server 层包括<strong>连接器</strong>、<strong>查询缓存</strong>、<strong>分析器</strong>、<strong>优化器</strong>、<strong>执行器</strong>等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如<strong>存储过程</strong>、<strong>触发器</strong>、<strong>视图</strong>等。不同的存储引擎共用一个 Server 层。</p> <p>而存储引擎层负责数据的存储和提取。其架构模式是<strong>插件式</strong>的，支持 <strong>InnoDB</strong>、<strong>MyISAM</strong>、<strong>Memory</strong> 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p> <div class="custom-block tip"><p class="custom-block-title">存储引擎简单对比：1、InnoDB支持事务，而MyISAM不支持事务 2、InnoDB支持行级锁，而MyISAM支持表级锁 3、InnoDB支持MVCC, 而MyISAM不支持 4、InnoDB支持外键，而MyISAM不支持 5、InnoDB不支持全文索引，而MyISAM支持。</p></div> <h3 id="连接器"><a href="#连接器" class="header-anchor">#</a> 连接器</h3> <p>不要将密码直接写在 <code>-p</code> 之后，这样会导致密码泄漏，通过 <code>history</code> 可以查看历史输入的命令。</p> <p>用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。<strong>权限信息连接建立时读到的快照</strong>，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。<strong>修改用户权限，不会影响已经存在的连接</strong>，只有再新建的连接才会使用新的权限设置。</p> <p>连接完成后，如果没有后续的动作，这个连接就处于空闲状态，通过 <code>show processlist;</code> 命令可以查看当前的连接。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。可以通过 <code>show variables like 'wait_timeout';</code>来查看。</p> <p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p> <p>数据库中，<strong>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接</strong>。<strong>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</strong>。建立连接的过程通常是比较复杂的，<strong>使用中要尽量减少建立连接的动作，也就是尽量使用长连接</strong>。</p> <p>全部使用长连接后，有些时候会导致 MySQL <strong>占用内存涨得特别快</strong>，这是因为 <strong>MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了</strong>。</p> <p><strong>解决长连接占用内存过大的两种方案</strong>：</p> <ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li> <li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol> <h3 id="查询缓存"><a href="#查询缓存" class="header-anchor">#</a> 查询缓存</h3> <p>Mysql拿到一个查询请求，会优先查看是否具有缓存，历史执行的语句是通过 key-value 对的形式，被直接缓存在内存中的，如果查询能够直接匹配缓存，value会被直接返回给客户端，不再进行后续操作。显然这样的效率会很高，但是<strong>查询缓存往往弊大于利</strong>，所以在<strong>mysql8.0中直接移除了查询缓存</strong>。</p> <h3 id="分析器"><a href="#分析器" class="header-anchor">#</a> 分析器</h3> <p>mysql需要你知道你要做什么，因此需要解析SQL，分析器会优先做词法分析，识别出语句中的字符串分别是什么，代表什么。然后需要做语法分析，根据语法规则判断输入的SQL是否满足语法要求，语句不对会收到“You have an error in your SQL syntax”的错误提醒。</p> <p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p> <h3 id="优化器"><a href="#优化器" class="header-anchor">#</a> 优化器</h3> <p>mysql知道你要做什么，还需要根据需求选择一个最优方案，决定怎么做，原则是尽可能扫描少的行记录。优化器<strong>会决定使用哪个索引，以及多表关联的连接顺序</strong>。</p> <h3 id="执行器"><a href="#执行器" class="header-anchor">#</a> 执行器</h3> <p>执行器在执行时，会判断对这个表有没有权限，没有权限会返回没有权限的错误。权限验证在分析器阶段也会做，叫做 “precheck”, 但是无法对运行中涉及的表进行权限验证，比如使用了触发器的情况，因此执行器阶段也需要做一次权限验证。</p> <p>执行器会根据表的引擎定义，去调用对应的引擎提供的API进行数据操作，所以数据库引擎是插件形式的。</p> <p>在没有索引的条件下执行器的执行流程是这样的：</p> <ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 是否满足条件，如果不是则跳过，如果是则将这行存在结果集中。</li> <li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li> <li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol> <p>有索引的情况，执行器调用的是SQL引擎的API，也就是说无索引是执行器过滤数据，有索引时是引擎接口过滤数据。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟 rows_examined 并不是完全相同的</strong> 。rows_examined代表执行器调用存储引擎的次数，一般情况小于引擎扫描行数。</p></div> <h3 id="日志模块"><a href="#日志模块" class="header-anchor">#</a> 日志模块</h3> <h4 id="redo-log-重做日志-innodb-特有"><a href="#redo-log-重做日志-innodb-特有" class="header-anchor">#</a> redo log (重做日志 InnoDB 特有)</h4> <p>mysql redo log 是 WAL（Write-Ahead-Logging），先写日志（redolog也在磁盘上，但是是连续的，顺序IO）后再择机（空闲时）持久化随机IO写回到磁盘，说白了就是把随机 IO 优化成顺序 IO, 使用最低的成本完成记录。有了 redo log InnoDB 就可以保证数据库发生异常重启时，之前提交的记录都不会丢，这个能力称为 <strong>crash-safe</strong>。</p> <blockquote><p>这里对比 Redis 是AOF，它是先做存储（Redis 是基于内存的，直接写入更快），再持久化到AOF日志中。</p></blockquote> <p>InnoDB 的 redo log 是固定大小的，比如可以配置一个4个文件每个文件是1G，从头开始写，写到末尾就回到开头循环写。如下图所示：</p> <p><img src="https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo/16a7950217b3f0f4ed02db5db59562a7.webp" alt=""></p> <p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p> <p>write pos 和 checkpoint 之间的空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示写满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>写满后“刷脏”，只是刷脏的一种方式，还有如下几种：</p> <p>1.后台线程定期会刷脏页</p> <p>2.清理LRU链表时会顺带刷脏页</p> <p>3.redoLog写满会强制刷</p> <p>4.数据库关闭时会将所有脏页刷回磁盘</p> <p>5.脏页数量过多（默认占缓冲池75%）时，会强制刷</p></div> <p>一些核心配置参数：</p> <ul><li><p><code>innodb_log_file_size</code></p> <p>该参数用来调整 redo log file 的大小，也就是我们在 mysql data 目录下看到的 iblogfile 文件。</p> <p>配置太小：会导致重做日志很容易写满，写满会切换日志文件，切换日志文件会导致强制刷大量“脏页”，影响服务器 TPS；</p> <p>配置太大：会加长 mysql 意外宕机的恢复时间，因为 Mysql 启动时会用 redo log 重做上次数据库关闭未及时刷盘的的数据页，重做页面越多，启动时间越长。</p></li> <li><p><code>innodb_log_files_in_group</code> 控制文件数</p></li> <li><p><code>innodb_adaptive_flushing</code> （mysql 5.5 新增）</p> <p>该参数影响每秒刷新脏页的操作，开启此配置后，刷新脏页会通过判断产生重做日志的速度来判断最合适的刷新脏页的数量。关闭会导致MySQL服务器的tps有明显的波动。每当重做日志写满了，MySQL就会停下手头的任务，先把脏页刷到磁盘里，才能继续干活</p></li> <li><p><code>innodb_adaptive_flushing_lwm</code>（mysql 5.5 新增）</p> <p>该参数可以设置redo log flush低水位线，当需要flush的redo log超过这个低水位时，innodb会立即启用adaptive flushing。</p></li> <li><p><code>innodb_flush_log_at_trx_commit</code></p> <p>0：事务提交时不会将 log buffer 中日志写入到 os buffer (什么都不做)，而是每秒写入 <code>os buffer</code> 并调用 <code>fsync()</code> 写入到 磁盘中的 log file。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据，但性能最好。</p> <p>1：事务每次提交都会将 log buffer 中的日志写入 os buffer 并调用 <code>fsync()</code> 刷到磁盘中的 log file。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差 但最安全。</p> <p>2：每次提交都仅写入到os buffer，然后是每秒调用fsync()将 os buffer 中的日志写入到磁盘中的 log file。</p></li></ul> <h4 id="bin-log-归档日志"><a href="#bin-log-归档日志" class="header-anchor">#</a> bin log (归档日志)</h4> <p>binlog 是 server 层的日志，redo log 是 InnoDB 特有的日志，binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。</p> <p><strong>为什么会有两种日志？</strong></p> <p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p> <p><strong>这两种日志有以下三点不同</strong>：</p> <ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li> <li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”</li> <li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol> <p><strong>update 语句的执行流程</strong>：</p> <ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li> <li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li> <li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li> <li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li> <li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol> <p>update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的：</p> <p><img src="https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo/2e5bff4910ec189fe1ee6e2ecc7b4bbe.webp" alt=""></p> <p><strong>两阶段提交</strong>：</p> <p>将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是&quot;两阶段提交&quot;。如果不使用“两阶段提交”，那么<strong>数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</strong>，<strong>两阶段提交就是让这两个状态保持逻辑上的一致</strong>。<strong>两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案</strong>。</p> <p><strong>建议设置</strong>：</p> <p>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p> <p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p> <h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <h4 id="事务的特性"><a href="#事务的特性" class="header-anchor">#</a> 事务的特性</h4> <p>ACID: 原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability）</p> <ul><li>原子性：一个事务中的所有操作，要不全部成功，要不全部失败，不会结束在某个中间环节。事务执行过程中如果发生错误，会被回滚到事务开始之前的状态，就像这个事务从来没有执行过一样。原子性的关注点在于事务的可中断性和异常的可恢复性。</li> <li>一致性：在事务开始之前和结束之后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。一致性的本质上是应用层对数据结果的预期结果。</li> <li>隔离性：数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行导致数据的不一致。隔离性关注并发访问的数据可见性。</li> <li>持久性：事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。持久性关注 <code>commit</code> 的事务数据被正确存储，异常断电数据也不会丢失。</li></ul> <h4 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="header-anchor">#</a> 隔离性与隔离级别</h4> <p>多个事务同时执行并且存在交叉时，可能出现脏读，幻读，不可重复读。</p> <ul><li>脏读：读取到其他事务未提交的数据。</li> <li>幻读：多次读取的记录条数不一样。</li> <li>不可重复读：多次读取的记录的内容不一致。</li></ul> <p><strong>事务隔离级别</strong>：</p> <ul><li>读未提交：一个事务还没提交时，他做的变更就能被别的事务读取到。</li> <li>读提交：一个事务提交之后，它做的更改才会被其他事务读取到。</li> <li>可重复读：一个事务执行过程中所看到的数据，总是与启动时看到的数据一致。实际上是锁定已经读取的数据，未提交前不允许其他事务修改。</li> <li>串行化：对于同一行记录的 “写” 会 “加锁”， “读” 也会 “加锁”，出现读写冲突时，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>以上隔离级别依次上升，隔离级别越高，并发性能越低，安全性越高。MySQL默认 可重复读（RR），Oracle 读提交（RC），postgresql 读提交（RC）。</p></div> <p>视图解释：</p> <ul><li>读未提交： 直接返回记录上的最新值，没有视图概念。</li> <li>读提交：MVCC视图会在每一个语句开始执行前创建一个。</li> <li>可重复读：MVCC视图在开始事务的时候就创建好了，这个视图会一直使用，直到事务结束。注意：<strong>开起事务方式为 begin 时， 视图是在第一条 select 语句执行前创建</strong>。</li> <li>串行化：直接加锁避免并行访问。</li></ul> <p><strong>配置方式</strong>：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 显示当前配置</span>
<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'transaction_isolation'</span><span class="token punctuation">;</span>
<span class="token comment">-- 设置全局</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span><span class="token punctuation">;</span>
<span class="token comment">-- 设置当前会话</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span><span class="token punctuation">;</span> 
</code></pre></div><p><strong>隔离实现</strong>：</p> <ul><li><p>更新回滚：</p> <p>每条记录在更新的时候，除了记录变更记录，还会记录一条变更记录相反的回滚操作记录，前者记录在 redo log, 后者记录在 undo  log。</p></li> <li><p>MVCC：:</p> <p>同一记录在系统中存在多个版本，就是数据库的多版本并发控制（MVCC）。</p></li> <li><p>回滚日志的保留：</p> <p>回滚日志不会一直保留，在不需要的时候就会删除。也就是说系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志就会删除。判断的依据是，系统里没有比这个回滚更早的 read-view 。mysql 会通过 purge 线程进行回收。</p></li> <li><p>避免使用长事务：</p> <p>长事务意味着系统里面会存在很老的事务视图，为了保证事务在执行期间看到的数据前后一致，那些老的事务视图，回滚日志就必须保留，这就会占用大量的存储空间，同时长事务还会占用锁资源，也会拖垮整个库。</p></li></ul> <p><strong>事务的启动方式</strong>：</p> <ol><li>显示启动事务语句，<code>begin</code> 或 <code>start transaction</code>。配套的提交语句是 commit，回滚语句是 rollback。</li> <li>set autocommit=0，这个命令会将这个线程的自动提交关掉，意味着如果你只执行一个 select 语句，事务就启动了，而且不会自动提交。这个事务持续存在直到主动执行 commit 或 rollback 语句，或者断开连接。</li></ol> <p>建议总是使用 set autocommit=1，并通过显示语句开始事务，这样可以一定程度上避免意外的长事务。<code>commit work and chain</code> 语法可以提交一个事务并自动启动下一个事务，省去再次执行 begin 的开销。</p> <p>可以在 information_schema 库的 innodb_trx 这个表中查询长事务，例如:</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 查找持续时间超过60秒的事务</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>innodb_trx <span class="token keyword">where</span> TIME_TO_SEC<span class="token punctuation">(</span>timediff<span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>trx_started<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">60</span>
</code></pre></div><p><strong>如何避免长事务：</strong></p> <p>开发端：</p> <ol><li>确认是否使用了 set autocommit=0，可用通过 general_log 的日志来确认。</li> <li>确实是否有不必要的只读事务。</li> <li>根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间</li></ol> <p>数据库端：</p> <ol><li><p>通过information_schema.innodb_trx表监控事务的持续时间，超过长事务阈值就报警或者kill。</p></li> <li><p>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题</p></li> <li><p>利用Percona 的 pt-kill 工具监控长事务。</p></li> <li><p>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便</p> <blockquote><p>innodb_undo_tablespaces  是控制undo是否开启独立的表空间的参数 0表示：undo使用系统表空间，即ibdata1; 不为0表示：使用独立的表空间，设定了创建的 undo 表空间的个数。</p></blockquote></li></ol> <h3 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h3> <h4 id="索引的常见模型"><a href="#索引的常见模型" class="header-anchor">#</a> 索引的常见模型</h4> <ol><li><p>哈希表</p> <ul><li><p>哈希表是一种 key-value 存储的数据结构，输入待查找的 key 就可以找到对应值的 value。哈希表的实现思路：把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组这个位置。</p></li> <li><p>不可避免，多个 key 通过哈希函数转换，可能会出现相同的值，处理这种问题的一种方式就是拉链法。</p></li> <li><p>在保证插入速度的前提下，哈希表不是有序的，所以哈希索引做区间查询的效率很慢。所以哈希表适用于只有等值查询的场景，比如 Memcached 及其他一些NoSQL引擎。</p></li></ul></li> <li><p>有序数组</p> <ul><li>有序数组在等值查询和范围查询的场景中性能都很优秀，但是需要更新数据的时候，需要往中间插入一条数据，不得不统一移动后面的所有记录，成本太高。</li> <li>有序数组索引只适用于静态存储引擎，适合那些保存后不再修改的数据。</li></ul></li> <li><p>搜索树</p> <ul><li><p>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父结点的值。查询复杂度为 O(log(N))，为了保证查询复杂度，需要保持这棵树是平衡二叉树，所以更新的时间也是 O(log(N))。</p></li> <li><p>多叉搜索树：每个结点有多个儿子，儿子之间的大小保证从左到右递增，二叉树搜索效率最高，但是由于二叉树树高过高，每次查询都需要访问过多的结点，即访问的数据块过多，而从磁盘随机访问数据块过于耗时（在机械硬盘时代，从磁盘随机读一个数据块需要10ms 左右的寻址时间），为了查询尽可能少读磁盘，就必须在查询时访问尽可能少的数据块，所以大多数数据库存储不使用二叉树，而是使用 “N 叉” 树。N 取决于数据块的大小。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>MySQL InnoDB 的 B+Tree 的每一个节点都是一个页， 默认一个节点的长度为16k，一个bigint 字段索引的长度为 8B，每个索引还会跟一个6B的指向子树的指针，16K/14B ≈ 1170（N的大小）。</p></div></li></ul></li></ol> <h4 id="innodb的索引模型"><a href="#innodb的索引模型" class="header-anchor">#</a> InnoDB的索引模型</h4> <p>InnoDB中表都是根据主键顺序以索引的形式存放的，这种存储方式的表叫索引组织表。InnnoDB使用了B+树的索引模型，所以数据都是存在 B+ 树中的。<strong>每一个索引在InnoDB中对应一个B+树</strong></p> <p><strong>B树和B+树的区别</strong>：</p> <p>B树结构图：</p> <p><img src="https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo/bcf303c4aa2ec04599ff778ee1e79b76.png" alt=""></p> <p>B+树结构图：</p> <p><img src="https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo/550bf776a034af98fbfdce91361cc6ff.png" alt=""></p> <ol><li>B+树非叶子节点不存数据，只存索引，B树的非叶子节点存储数据。</li> <li>B+树使用双向链表串连所有子节点，区间查询效率高，因为所有数据都在叶子节点，但是B树需要通过中序遍历才能完成范围查找。</li> <li>B+树每次必须查询到叶子节点才能找到数据，而B树查询的数据可能不在叶子节点，也可能在，这样导致查询效率不稳定。</li> <li>B+树的查询效率更高，因为B+树更矮胖，高度小，产生的I/O次最少。（MySQL中访问数据要通过页，一个页就是一个B+树节点，访问一个节点相当于一次I/O操作）</li></ol> <p><strong>MySQL表的存储结构</strong>：</p> <p><img src="https://ling-root-bucket.oss-cn-hangzhou.aliyuncs.com/picgo/aca38087f94903beef319d5f223e18b1.png" alt=""></p> <ul><li><p>在InnoDB 中，每一张表其实就是多个 B+ 树，即一个主键索引树和多个非主键索引树。</p></li> <li><p>主键索引的叶子节点存的是整行数据，在InnoDB里，主键索引也被成为聚簇索引。</p></li> <li><p>非主键索引的叶子节点存的是主键的值，在InnnoDB里，也被称为二级索引。</p></li></ul> <p><strong>基于主键索引和普通索引的查询有什么区别</strong>：</p> <ol><li>如果语句是 <code>select * from T where ID=500</code> 根据主键查询，只需要搜索主键索引树。</li> <li>如果语句是 <code>select * from T where k=5</code> 根据普通索引查询，需要先搜索 k 索引树找出主键值，再到ID索引树种搜索一次，这个过程称为回表。</li></ol> <p>总结就是基于非主键索引的查询需要多扫描一棵索引树，因此应该尽量使用主键查询。</p> <h4 id="索引的维护"><a href="#索引的维护" class="header-anchor">#</a> 索引的维护</h4> <p>B+树为了索引的有序性，在插入新值时需要做必要的维护，如果是往中间插入，那么逻辑上需要挪动后面的数据空出位置，更糟糕的情况是，如果插入的数据页满了，需要申请一个新页，然后挪动部分数据过去，这个过程称为页分裂。这种情况下，性能自然会受到影响。除了性能外，页分裂还会影响页的利用率，原本一页的数据分到了两个页，整体空间利用率降低大约50%。</p> <p>自增主键可以保证新的ID一定在叶子节点最右边，不会影响前面的数据，所以可以防止页分裂。所以推荐使用自增ID。</p> <p>当相邻两个页由于删除了数据，导致利用率很低（默认为50%）之后，会导致页合并，删除本身是标记删除，并不会释放磁盘（线上很多磁盘快满了, 就是释放不掉的问题）。逻辑删除可以防止页合并。</p> <p><strong>使用自增主键的场景和不适用自增主键的场景</strong></p> <h2 id="疑难解答"><a href="#疑难解答" class="header-anchor">#</a> 疑难解答</h2> <ol><li><code>select * from tableA group by cid</code> 语句返回的非 group 字段值到底是什么?</li></ol> <p>答: group by 时，那些不参与 grouping 的字段具体返回哪条数据在 MySQL5.7 (包括5.7) 之前的版本处于未定义规则状态，官方文档不承诺一定会返回哪条数据， group by 返回的是根据主键顺序，也是没有依据的。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">1/26/2024, 2:01:44 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/database/redis.html" class="prev">
        Redis
      </a></span> <span class="next"><a href="/database/mongodb.html">
        MongoDB
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8b02bca0.js" defer></script><script src="/assets/js/2.f0a5ede2.js" defer></script><script src="/assets/js/1.b1f9bc46.js" defer></script><script src="/assets/js/30.a38e59fa.js" defer></script>
  </body>
</html>
